"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptPackageUpdate = exports.promptConfig = exports.promptConfirmCommit = exports.promptCommitMessage = exports.promptIssues = exports.promptBreakingChanges = exports.promptBody = exports.promptHeader = exports.promptSubject = exports.promptScope = exports.promptType = void 0;
const formatmsg_1 = require("./formatmsg");
const config_1 = require("./config");
const scopes_1 = require("./scopes");
const enquirer_1 = require("enquirer");
const suggest_prompt_1 = __importDefault(require("./suggest-prompt"));
const commitlint_1 = require("./commitlint");
async function promptType(message = {}, config = config_1.DefaultConfig) {
    const { type } = await (0, enquirer_1.prompt)({
        name: 'type',
        message: "type:    " /* PromptMessage.TYPE */,
        type: 'autocomplete',
        choices: config.types,
        initial: config.types.indexOf(message.type),
    });
    return Object.assign(message, { type });
}
exports.promptType = promptType;
async function promptScope(scopes, message = {}, config = config_1.DefaultConfig) {
    if (scopes && scopes.length) {
        if (config.promptScope == 'enforce') {
            const { scope } = await (0, enquirer_1.prompt)({
                type: 'autocomplete',
                name: 'scope',
                message: "scope:   " /* PromptMessage.SCOPE */,
                choices: scopes,
                result: (input) => input.toLowerCase().trim(),
                initial: scopes.indexOf(message.scope),
            });
            return Object.assign(message, { scope });
        }
        else {
            const scope = await new suggest_prompt_1.default({
                name: 'scope',
                message: "scope:   " /* PromptMessage.SCOPE */,
                suggestions: scopes,
                result: (input) => input.toLowerCase(),
                validate: (input) => !!input.trim() || 'scope can not be empty',
            }).run();
            return Object.assign(message, { scope });
        }
    }
    else {
        const { scope } = await (0, enquirer_1.prompt)({
            type: 'input',
            name: 'scope',
            message: "scope:   " /* PromptMessage.SCOPE */,
            initial: message.scope,
            result: (input) => input.toLowerCase().trim(),
            validate(input) {
                if (config.promptScope == 'enforce') {
                    return !!input.trim() || 'scope can not be empty';
                }
                return true;
            },
        });
        return Object.assign(message, { scope });
    }
}
exports.promptScope = promptScope;
async function promptSubject(message = {}, config = config_1.DefaultConfig) {
    const { rules } = await (0, commitlint_1.loadOptions)(config);
    const { subject } = await (0, enquirer_1.prompt)({
        type: 'input',
        name: 'subject',
        message: "subject: " /* PromptMessage.SUBJECT */,
        initial: message.subject,
        result: (input) => input.trim(),
        validate(input) {
            const result = (0, commitlint_1.validateSubject)(input, rules);
            if (result != true)
                return result;
            const header = (0, formatmsg_1.formatHeader)(message.type, message.scope, input);
            if (header.length >= 72) {
                return 'subject is too long';
            }
            return true;
        },
    });
    return Object.assign(message, { subject });
}
exports.promptSubject = promptSubject;
async function promptHeader(message = {}, config = config_1.DefaultConfig) {
    const getscopes = (0, scopes_1.suggestScopes)(config);
    message = await promptType(message, config);
    const scopes = (await getscopes).map((s) => s.toLowerCase());
    if (!!config.promptScope) {
        message = await promptScope(scopes, message, config);
    }
    message = await promptSubject(message, config);
    return message;
}
exports.promptHeader = promptHeader;
async function promptBody(message = {}, config = config_1.DefaultConfig) {
    const lines = message.body || [];
    const body = [];
    for (let i = 0; i < 20; i++) {
        const { line } = await (0, enquirer_1.prompt)({
            type: 'input',
            name: 'line',
            message: "body:    " /* PromptMessage.BODY */,
            initial: (lines && lines[i]) || undefined,
            result: (input) => input.trim(),
        });
        if (!line)
            break;
        body.push(line);
    }
    return Object.assign(message, { body });
}
exports.promptBody = promptBody;
async function promptBreakingChanges(message = {}, config = config_1.DefaultConfig) {
    const { breaking } = await (0, enquirer_1.prompt)({
        type: 'input',
        name: 'breaking',
        message: "breaks:  " /* PromptMessage.BREAK */,
        initial: message.breaking || undefined,
        result: (input) => input.trim(),
    });
    return Object.assign(message, { breaking });
}
exports.promptBreakingChanges = promptBreakingChanges;
async function promptIssues(message = {}, config = config_1.DefaultConfig) {
    const lines = message.issues || [];
    const result = [];
    for (let i = 0; i < 20; i++) {
        const { issue } = await (0, enquirer_1.prompt)({
            type: 'input',
            name: 'issue',
            message: "issues:  " /* PromptMessage.ISSUE */,
            initial: (lines && lines[i]) || undefined,
            result: (input) => input.trim(),
        });
        if (!issue)
            break;
        result.push(...issue.split(/,|;/));
    }
    const issues = result.filter((issue) => !!issue);
    return Object.assign(message, { issues });
}
exports.promptIssues = promptIssues;
async function promptCommitMessage(message = {}, config = config_1.DefaultConfig) {
    const header = await promptHeader(message, config);
    message = Object.assign(message, header);
    if (config.promptBody) {
        message = await promptBody(message, config);
    }
    if (config.promptBreaking) {
        message = await promptBreakingChanges(message, config);
    }
    if (config.promptIssues) {
        message = await promptIssues(message, config);
    }
    return message;
}
exports.promptCommitMessage = promptCommitMessage;
async function promptConfirmCommit(config = config_1.DefaultConfig) {
    if (!config.promptConfirm)
        return true;
    const { commit } = (await (0, enquirer_1.prompt)({
        type: 'confirm',
        name: 'commit',
        message: "commit?  " /* PromptMessage.CONFIRM */,
        initial: true,
        format: (input) => (input ? 'Yes' : 'no'),
    }));
    return commit;
}
exports.promptConfirmCommit = promptConfirmCommit;
async function promptConfig() {
    const typeChoices = [
        'feat',
        'fix',
        'chore',
        'build',
        'ci',
        'docs',
        'perf',
        'refactor',
        'revert',
        'style',
        'test',
    ];
    const answers = await (0, enquirer_1.prompt)([
        {
            type: 'multiselect',
            name: 'types',
            message: 'types',
            choices: typeChoices,
            // initial: ['feat', 'fix', 'chore', 'docs', 'refactor', 'test']
        },
        {
            type: 'select',
            name: 'promptScope',
            message: 'scope',
            choices: [
                { name: 'none', message: 'no scope' },
                { name: 'suggest', message: 'suggest scope' },
                { name: 'enforce', message: 'enforce scope' },
            ],
        },
        {
            type: 'select',
            name: 'scopes',
            message() {
                const answers = this.state.answers;
                return ` ${answers.promptScope}  scope`;
            },
            choices: [
                { name: 'staged', message: 'from staged files' },
                { name: 'packages', message: 'from package names (monorepo)' },
                { name: 'list', message: 'from a list' },
            ],
            skip() {
                const answers = this.state.answers;
                return answers.promptScope == 'none';
            },
        },
        {
            type: 'list',
            name: 'scopeList',
            message: 'type comma-separated scope names',
            skip() {
                const answers = this.state.answers;
                return answers.scopes != 'list';
            },
        },
    ]);
    const { types, promptScope, scopes, scopeList } = answers;
    const config = { types };
    if (promptScope != 'none') {
        config.promptScope = promptScope;
        config.scopes = scopes == 'list' ? scopeList : scopes;
    }
    return config;
}
exports.promptConfig = promptConfig;
async function promptPackageUpdate() {
    const { updatePackage } = await (0, enquirer_1.prompt)({
        type: 'select',
        name: 'updatePackage',
        message: 'save config in',
        choices: [{ name: '.standard-commitrc.json' }, { name: 'package.json' }],
    });
    return {
        updatePackage: updatePackage == 'package.json',
    };
}
exports.promptPackageUpdate = promptPackageUpdate;
