"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const child_process_1 = require("child_process");
const graphql_1 = require("graphql");
const fromIntrospectionQuery_1 = require("./lib/fromIntrospectionQuery");
const nativeScalarsToFilter = ['String', 'Int', 'Boolean'];
const readmeSDL = `
  type Todo {
      id: ID!
      name: String!
      completed: Boolean
      color: Color

      "A field that requires an argument"
      colors(
        filter: [Color!]!
      ): [Color!]!
  }

  type SimpleTodo {
    id: ID!
    name: String!
  }

  union TodoUnion = Todo | SimpleTodo

  input TodoInputType {
      name: String!
      completed: Boolean
      color: Color=RED
  }

  enum Color {
      "Red color"
      RED
      "Green color"
      GREEN
  }

  type Query {
      "A Query with 1 required argument and 1 optional argument"
      todo(
        id: ID!,
        "A default value of false"
        isCompleted: Boolean=false
      ): Todo

      "Returns a list (or null) that can contain null values"
      todos(
        "Required argument that is a list that cannot contain null values"
        ids: [String!]!
      ): [Todo]
  }

  type Mutation {
      "A Mutation with 1 required argument"
      create_todo(
        todo: TodoInputType!
      ): Todo!

      "A Mutation with 2 required arguments"
      update_todo(
        id: ID!,
        data: TodoInputType!
      ): Todo!

      "Returns a list (or null) that can contain null values"
      update_todos(
        ids: [String!]!
        data: TodoInputType!
      ): [Todo]
  }
`;
const readmeSchema = graphql_1.buildSchema(readmeSDL);
const introspectionQueryJSON = graphql_1.graphqlSync(readmeSchema, graphql_1.getIntrospectionQuery()).data;
const options = {
    nullableArrayItems: true,
};
const readmeResult = fromIntrospectionQuery_1.fromIntrospectionQuery(introspectionQueryJSON, options);
const cleanedUpReadmeResult = JSON.parse(JSON.stringify(readmeResult));
const startsWithTestGenerator = (stringToTest) => {
    return (stringToLookFor) => stringToTest.startsWith(`${stringToLookFor}:`);
};
const keyComparator = (a, b) => {
    if (['description'].some(startsWithTestGenerator(a))) {
        return ['description'].some(startsWithTestGenerator(b)) ? 0 : -1;
    }
    if (['description'].some(startsWithTestGenerator(b))) {
        return 1;
    }
    if (nativeScalarsToFilter.some(startsWithTestGenerator(a))) {
        return nativeScalarsToFilter.some(startsWithTestGenerator(b)) ? 0 : 1;
    }
    if (nativeScalarsToFilter.some(startsWithTestGenerator(b))) {
        return -1;
    }
    return 0;
};
const output = `### Input

\`\`\`graphql${readmeSDL}\`\`\`

### Output

\`\`\`js
// Output is from call to fromIntrospectionQuery with the following options:
const options = ${util_1.inspect(options)}

${util_1.inspect(cleanedUpReadmeResult, { depth: null, sorted: keyComparator })}
\`\`\`
`;
console.log(`
<BEGIN OUTPUT>
${output}
<END OUTPUT>
`);
if (process.platform === 'darwin') {
    const proc = child_process_1.spawn('pbcopy');
    proc.stdin.write(output);
    proc.stdin.end();
    console.log('OUTPUT COPIED TO YOUR CLIPBOARD!!!\n');
}
