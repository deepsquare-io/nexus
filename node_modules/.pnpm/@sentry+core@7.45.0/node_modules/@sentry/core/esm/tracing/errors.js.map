{"version":3,"file":"errors.js","sources":["../../../src/tracing/errors.ts"],"sourcesContent":["import { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport type { SpanStatusType } from './span';\nimport { getActiveTransaction } from './utils';\n\nlet errorsInstrumented = false;\n\n/**\n * Configures global error listeners\n */\nexport function registerErrorInstrumentation(): void {\n  if (errorsInstrumented) {\n    return;\n  }\n\n  errorsInstrumented = true;\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status: SpanStatusType = 'internal_error';\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = 'sentry_tracingErrorCallback';\n"],"names":[],"mappings":";;;AAKA,IAAA,kBAAA,GAAA,KAAA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,4BAAA,GAAA;AACA,EAAA,IAAA,kBAAA,EAAA;AACA,IAAA,OAAA;AACA,GAAA;AACA;AACA,EAAA,kBAAA,GAAA,IAAA,CAAA;AACA,EAAA,yBAAA,CAAA,OAAA,EAAA,aAAA,CAAA,CAAA;AACA,EAAA,yBAAA,CAAA,oBAAA,EAAA,aAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,aAAA,GAAA;AACA,EAAA,MAAA,iBAAA,GAAA,oBAAA,EAAA,CAAA;AACA,EAAA,IAAA,iBAAA,EAAA;AACA,IAAA,MAAA,MAAA,GAAA,gBAAA,CAAA;AACA,IAAA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,GAAA,CAAA,CAAA,uBAAA,EAAA,MAAA,CAAA,wBAAA,CAAA,CAAA,CAAA;AACA,IAAA,iBAAA,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA;AACA,GAAA;AACA,CAAA;AACA;AACA;AACA;AACA,aAAA,CAAA,GAAA,GAAA,6BAAA;;;;"}