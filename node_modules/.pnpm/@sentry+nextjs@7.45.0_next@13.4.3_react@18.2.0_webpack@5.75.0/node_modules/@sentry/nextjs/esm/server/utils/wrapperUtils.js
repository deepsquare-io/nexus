import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { startTransaction, getCurrentHub, getActiveTransaction, captureException } from '@sentry/core';
import { extractTraceparentData, baggageHeaderToDynamicSamplingContext } from '@sentry/utils';
import * as domain from 'domain';
import { platformSupportsStreaming } from './platformSupportsStreaming.js';
import { autoEndTransactionOnResponseEnd, flushQueue } from './responseEnd.js';

/**
 * Grabs a transaction off a Next.js datafetcher request object, if it was previously put there via
 * `setTransactionOnRequest`.
 *
 * @param req The Next.js datafetcher request object
 * @returns the Transaction on the request object if there is one, or `undefined` if the request object didn't have one.
 */
function getTransactionFromRequest(req) {
  return req._sentryTransaction;
}

function setTransactionOnRequest(transaction, req) {
  req._sentryTransaction = transaction;
}

/**
 * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.
 *
 * Note: This function turns the wrapped function into an asynchronous one.
 */
function withErrorInstrumentation(
  origFunction,
) {
  return async function ( ...origFunctionArguments) {
    try {
      return await origFunction.apply(this, origFunctionArguments);
    } catch (e) {
      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.
      captureException(e);
      throw e;
    }
  };
}

/**
 * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing
 * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to
 * a span for the wrapped data fetching function.
 *
 * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.
 *
 * @param origDataFetcher The data fetching method to call.
 * @param origFunctionArguments The arguments to call the data fetching method with.
 * @param req The data fetching function's request object.
 * @param res The data fetching function's response object.
 * @param options Options providing details for the created transaction and span.
 * @returns what the data fetching method call returned.
 */
function withTracedServerSideDataFetcher(
  origDataFetcher,
  req,
  res,
  options

,
) {
  return async function ( ...args) {
    return domain.create().bind(async () => {
      let requestTransaction = getTransactionFromRequest(req);
      let dataFetcherSpan;

      const sentryTraceHeader = req.headers['sentry-trace'];
      const rawBaggageString = req.headers && req.headers.baggage;
      const traceparentData =
        typeof sentryTraceHeader === 'string' ? extractTraceparentData(sentryTraceHeader) : undefined;

      const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(rawBaggageString);

      if (platformSupportsStreaming()) {
        if (requestTransaction === undefined) {
          const newTransaction = startTransaction(
            {
              op: 'http.server',
              name: options.requestedRouteName,
              ...traceparentData,
              status: 'ok',
              metadata: {
                request: req,
                source: 'route',
                dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
              },
            },
            { request: req },
          );

          requestTransaction = newTransaction;

          if (platformSupportsStreaming()) {
            // On platforms that don't support streaming, doing things after res.end() is unreliable.
            autoEndTransactionOnResponseEnd(newTransaction, res);
          }

          // Link the transaction and the request together, so that when we would normally only have access to one, it's
          // still possible to grab the other.
          setTransactionOnRequest(newTransaction, req);
        }

        dataFetcherSpan = requestTransaction.startChild({
          op: 'function.nextjs',
          description: `${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`,
          status: 'ok',
        });
      } else {
        dataFetcherSpan = startTransaction({
          op: 'function.nextjs',
          name: `${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`,
          ...traceparentData,
          status: 'ok',
          metadata: {
            request: req,
            source: 'route',
            dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
          },
        });
      }

      const currentScope = getCurrentHub().getScope();
      if (currentScope) {
        currentScope.setSpan(dataFetcherSpan);
        currentScope.setSDKProcessingMetadata({ request: req });
      }

      try {
        return await origDataFetcher.apply(this, args);
      } catch (e) {
        // Since we finish the span before the error can bubble up and trigger the handlers in `registerErrorInstrumentation`
        // that set the transaction status, we need to manually set the status of the span & transaction
        dataFetcherSpan.setStatus('internal_error');
        _optionalChain([requestTransaction, 'optionalAccess', _ => _.setStatus, 'call', _2 => _2('internal_error')]);
        throw e;
      } finally {
        dataFetcherSpan.finish();
        if (!platformSupportsStreaming()) {
          await flushQueue();
        }
      }
    })();
  };
}

/**
 * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.
 *
 * We only do the following until we move transaction creation into this function: When called, the wrapped function
 * will also update the name of the active transaction with a parameterized route provided via the `options` argument.
 */
async function callDataFetcherTraced(
  origFunction,
  origFunctionArgs,
  options

,
) {
  const { parameterizedRoute, dataFetchingMethodName } = options;

  const transaction = getActiveTransaction();

  if (!transaction) {
    return origFunction(...origFunctionArgs);
  }

  // TODO: Make sure that the given route matches the name of the active transaction (to prevent background data
  // fetching from switching the name to a completely other route) -- We'll probably switch to creating a transaction
  // right here so making that check will probabably not even be necessary.
  // Logic will be: If there is no active transaction, start one with correct name and source. If there is an active
  // transaction, create a child span with correct name and source.
  transaction.name = parameterizedRoute;
  transaction.metadata.source = 'route';

  // Capture the route, since pre-loading, revalidation, etc might mean that this span may happen during another
  // route's transaction
  const span = transaction.startChild({
    op: 'function.nextjs',
    description: `${dataFetchingMethodName} (${parameterizedRoute})`,
    status: 'ok',
  });

  try {
    return await origFunction(...origFunctionArgs);
  } catch (err) {
    // Since we finish the span before the error can bubble up and trigger the handlers in `registerErrorInstrumentation`
    // that set the transaction status, we need to manually set the status of the span & transaction
    transaction.setStatus('internal_error');
    span.setStatus('internal_error');
    span.finish();

    // TODO Copy more robust error handling over from `withSentry`
    captureException(err);
    throw err;
  }
}

export { callDataFetcherTraced, getTransactionFromRequest, withErrorInstrumentation, withTracedServerSideDataFetcher };
//# sourceMappingURL=wrapperUtils.js.map
